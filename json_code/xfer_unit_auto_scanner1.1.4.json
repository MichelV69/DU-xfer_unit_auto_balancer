{
  "slots": {
    "0": {
      "name": "XFR1",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "1": {
      "name": "OutputBin",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "2": {
      "name": "InputBin1",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "3": {
      "name": "Screen",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "4": {
      "name": "slot5",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "5": {
      "name": "slot6",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "6": {
      "name": "slot7",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "7": {
      "name": "slot8",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "8": {
      "name": "slot9",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "9": {
      "name": "slot10",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-1": {
      "name": "unit",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-3": {
      "name": "player",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-2": {
      "name": "construct",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-4": {
      "name": "system",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-5": {
      "name": "library",
      "type": {
        "events": [],
        "methods": []
      }
    }
  },
  "handlers": [
    {
      "code": "--- unit.onStart(1)\nwss_software ={}\nwss_software.id = \"xfer_unit_auto_scanner\"\nwss_software.title = \"Transfer Unit Auto-Scanner / Auto-Balancer\"\nwss_software.version = \"1.1.4\"\nwss_software.revision = \"08 JAN 2023 18h30 AST\"\nwss_software.author = \"Michel Vaillancourt <902pe_gaming@wolfstar.ca>\"\n\nsystem.print(\"\\n --------------- \\n\")\nmsgTitleAndVersion = wss_software.title .. \"\\n\" .. wss_software.version\nsystem.print(msgTitleAndVersion)\n\n---\nprecisionDigits = 2\nprecisionValue  = 10^precisionDigits\ngramsToKG = 1000\nminutes = {}\nminutes[1] = 60\nminutes[2] = minutes[1]*2\nminutes[5] = minutes[1]*5\n\nstatusCodeTable = {}\nstatusCodeTable[1] = {state=\"Stopped\"}\nstatusCodeTable[2] = {state=\"Pending\"}\nstatusCodeTable[3] = {state=\"Jammed\"}\nstatusCodeTable[4] = {state=\"Storage Full\"}\nstatusCodeTable[5] = {state=\"No Output\"}\nstatusCodeTable[6] = {state=\"Running\"}\nstatusCodeTable[7] = {state=\"No Schemas\"}\n\nstatusMessageTable = {}\nstatusMessageTable[\"XFRUL_Status\"] = \"Booting\"\nstatusMessageTable[\"XFR_Data\"] = {material=\"Unknown\", quantity=-1}\nstatusMessageTable[\"comment\"] = \"Booting\"\n\nscreenPulseTable = {}\nscreenPulseTable[1]  = \"[-=+     ]\"\nscreenPulseTable[2]  = \"[ -=+    ]\"\nscreenPulseTable[3]  = \"[  -=+   ]\"\nscreenPulseTable[4]  = \"[   -=+  ]\"\nscreenPulseTable[5]  = \"[    -=+ ]\"\nscreenPulseTable[6]  = \"[     -=+]\"\nscreenPulseTable[7]  = \"[     -+=]\"\nscreenPulseTable[8]  = \"[     +=-]\"\nscreenPulseTable[9]  = \"[    +=- ]\"\nscreenPulseTable[10] = \"[   +=-  ]\"\nscreenPulseTable[11] = \"[  +=-   ]\"\nscreenPulseTable[12] = \"[ +=-    ]\"\nscreenPulseTable[13] = \"[+=-     ]\"\nscreenPulseTable[14] = \"[=+-     ]\"\nscreenPulseTable[15] = \"[=-+     ]\"\nanimationPulseIndex = 1\n\n---\nmsgTag={}\nmsgTag[\"default\"] = wss_software.id\nmsgTag[\"inBin\"]  = \"_inputBinsContents\"\nmsgTag[\"outBin\"] = \"_outputBinContents\"\nmsgTag[\"screen\"] = \"_updateScreen\"\n\ntickTimeSeconds = 21\ncontainerVisibleGrid = 7 * 6\n\n--- test stuff is plugged in\nsystem.print(\"\\n --------------- \\n\")\nsystem.print(wss_software.id .. \":\".. XFR1.getClass() .. \":\" ..XFR1.getName())\nsystem.print(wss_software.id .. \":\".. InputBin1.getClass() .. \":\" ..InputBin1.getName() .. \":\"..roundDownToPrecision(InputBin1.getItemsVolume()) .. \"L Used\")\nsystem.print(wss_software.id .. \":\".. OutputBin.getClass() .. \":\" ..OutputBin.getName() .. \":\"..roundDownToPrecision(OutputBin.getItemsVolume()) .. \"L Used\")\n\noutputBinBigChunk = roundDownToPrecision(OutputBin.getMaxVolume()/containerVisibleGrid)\n\nsystem.print(wss_software.id .. \": Transfer Chunk Cap will be \"..outputBinBigChunk.. \"L\")\n\n---\nlocal lclFontName= \"Montserrat-Light\" --export\nFontName=[[\"]].. lclFontName ..[[\"]]\nFontSize= 20 --export\n\n---\ninputBinsContents = {}\noutputBinContents = {}\n\nScreen.activate()\nScreen.setCenteredText(msgTitleAndVersion .. \"\\n\\n BOOTING\")\n\nsystem.print(wss_software.id..\":\" .. OutputBin.getName() .. \":arming timer for first maximum first run delay in [\"..minutes[1]..\"] seconds\")\nunit.setTimer(wss_software.id, minutes[1]) \nunit.setTimer(msgTag[\"outBin\"],tickTimeSeconds)\nunit.setTimer(msgTag[\"screen\"],tickTimeSeconds)\n\n---eof---",
      "filter": {
        "args": [],
        "signature": "onStart()",
        "slotKey": "-1"
      },
      "key": "0"
    },
    {
      "code": "local tagName = msgTag[\"default\"]\nunit.stopTimer(msgTag[\"default\"])\n\nloadTablesForBalancing()\ncheckBalancer()\nunit.setTimer(tagName, tickTimeSeconds)",
      "filter": {
        "args": [
          {
            "value": "xfer_unit_auto_scanner"
          }
        ],
        "signature": "onTimer(tag)",
        "slotKey": "-1"
      },
      "key": "1"
    },
    {
      "code": "---unit.OnStop(1)\nunit.stopTimer(msgTag[\"default\"])\nunit.stopTimer(msgTag[\"inBin\"])\nunit.stopTimer(msgTag[\"outBin\"])\nunit.stopTimer(msgTag[\"screen\"])\nXFR1.stop()\nScreen.setCenteredText(msgTitleAndVersion .. \"\\n\\n STOPPED\")\n--- eof",
      "filter": {
        "args": [],
        "signature": "onStop()",
        "slotKey": "-1"
      },
      "key": "2"
    },
    {
      "code": "local tagName = msgTag[\"outBin\"]\nunit.stopTimer(msgTag[\"outBin\"])\n\nif balancerIsFree() then\n    local retrySeconds = OutputBin.updateContent()\n\n    if retrySeconds == 0 then\n        loadTablesForBalancing()\n        unit.setTimer(msgTag[\"inBin\"], tickTimeSeconds)\n        else\n        statusMessageTable[\"comment\"] = \"(waiting for OutputBin to answer)\"\n        unit.setTimer(tagName, retrySeconds)\n        end\n\n    else\n    unit.setTimer(tagName, minutes[2])\n    end",
      "filter": {
        "args": [
          {
            "value": "_outputBinContents"
          }
        ],
        "signature": "onTimer(tag)",
        "slotKey": "-1"
      },
      "key": "3"
    },
    {
      "code": "local tagName = msgTag[\"inBin\"]\nunit.stopTimer(msgTag[\"inBin\"])\n\nif balancerIsFree() then\n    local retrySeconds = InputBin1.updateContent()\n\n    if retrySeconds == 0 then\n        loadTablesForBalancing()\n        unit.setTimer(msgTag[\"outBin\"], tickTimeSeconds)\n        else\n        statusMessageTable[\"comment\"] = \"(waiting for InputBin to answer)\"\n        unit.setTimer(tagName, retrySeconds)\n        end\n    \n    else\n    unit.setTimer(tagName, minutes[2])\n    end",
      "filter": {
        "args": [
          {
            "value": "_inputBinsContents"
          }
        ],
        "signature": "onTimer(tag)",
        "slotKey": "-1"
      },
      "key": "4"
    },
    {
      "code": "local tagName = msgTag[\"screen\"]\nunit.stopTimer(tagName)\n\n---===\ntidyInBinContents = {}\n\nfor _,column in ipairs(inputBinsContents) do\n    local itemID   = column[1]\n    local quantity = column[3]\n    local item = system.getItem(itemID)\n    local item_data = { item.locDisplayNameWithSize, quantity}\n    table.insert(tidyInBinContents, item_data)\n    end\n\ncol_quantity=2\ntable.sort(tidyInBinContents, function(a, b) return a[col_quantity] > b[col_quantity] end)\n---===\n\nlocal json=require('dkjson')\nScreen.setScriptInput(json.encode(tidyInBinContents))\nupdateBalancerStatusInfo()\nrenderScreen()\n\nunit.setTimer(tagName,0.5)",
      "filter": {
        "args": [
          {
            "value": "_updateScreen"
          }
        ],
        "signature": "onTimer(tag)",
        "slotKey": "-1"
      },
      "key": "5"
    },
    {
      "code": "-- library.onStart(1)\n-- define key functions for use elsewhere\n---\nfunction roundUpToPrecision(valueToRound)\n  if valueToRound == nil then return 0 end\n  local roundedValue = (math.ceil(valueToRound * precisionValue) / precisionValue)\n  return roundedValue\n  end\n\n---\nfunction roundDownToPrecision(valueToRound)\n  if valueToRound == nil then return 0 end\n  local roundedValue = (math.floor(valueToRound * precisionValue) / precisionValue)\n  return roundedValue\n  end\n\n---\nfunction balancerIsBusy()\n  local balancerStatus = XFR1.getState()\n  isBusy = false\n  if balancerStatus == 2\n    or balancerStatus == 6 then\n      isBusy = true\n      end\n  return isBusy\n  end\n\nfunction balancerIsFree()\n  return (balancerIsBusy() == false)\n  end\n\n---\nfunction updateBalancerStatusInfo()\n  local balancerStatus = XFR1.getState()\n  statusMessageTable[\"XFRUL_Status\"] = statusCodeTable[balancerStatus].state\n  end\n\n---\nfunction checkBalancer()\n  statusMessageTable[\"XFRUL_Status\"] = \"Unknown\"\n  statusMessageTable[\"XFR_Data\"] = {material = \"Unknown\", quantity = -1}\n  statusMessageTable[\"comment\"] = \"checkBalancer running\"\n\n  unit.stopTimer(wss_software.id)\n  updateBalancerStatusInfo()\n  \n  if balancerIsBusy() then\n    statusMessageTable[\"comment\"] = \"XFRU-L busy on prior order\"\n    else\n    runBalancer()\n    end\n\n  unit.setTimer(wss_software.id, tickTimeSeconds)\n  end\n\n---\nfunction runBalancer()\n  statusMessageTable[\"XFRUL_Status\"] = \"Unknown\"\n  statusMessageTable[\"XFR_Data\"] = {material = \"Unknown\", quantity = -1}\n  statusMessageTable[\"comment\"]  = \"runBalancer running\"\n  \n  XFR1.stop()\n  updateBalancerStatusInfo()\n\n  if #inputBinsContents == 0\n    or #outputBinContents == 0\n      then\n        statusMessageTable[\"comment\"] = \"Bin Data Not Yet Aquired\"\n        return \n        end\n\n  col_quantity=3\n  table.sort(inputBinsContents, function(a, b) return a[col_quantity] > b[col_quantity] end)\n\n  for row, column in ipairs(inputBinsContents) do --- 1\n    inputBinOreLitresAvailable = column[3]\n    outputBinOreLitresRequired = outputBinBigChunk\n    inputBinOreID   = column[1]\n    inputBinOreName = column[2]\n    \n    statusMessageTable[\"XFR_Data\"] = {material = inputBinOreID, quantity = -1}\n    statusMessageTable[\"comment\"]  = \"Searching Output Bins\"\n    \n    oreNotFoundInOutputBin = true\n\n    for row2, column2 in ipairs(outputBinContents) do\n      if column2[1] == inputBinOreID then\n        oreNotFoundInOutputBin = false\n        outputBinOreLitresAlreadyPresent = column2[3]\n        outputBinOreLitresRequired = outputBinBigChunk - outputBinOreLitresAlreadyPresent\n\n        statusMessageTable[\"XFR_Data\"] = {material = inputBinOreName, quantity = outputBinOreLitresRequired}\n\n        if outputBinOreLitresRequired > inputBinOreLitresAvailable then outputBinOreLitresRequired = 0 end\n        if outputBinOreLitresAlreadyPresent > inputBinOreLitresAvailable then outputBinOreLitresRequired = 0 end\n      end\n    end\n\n    if oreNotFoundInOutputBin then\n        outputBinOreLitresRequired = outputBinBigChunk\n        if outputBinOreLitresRequired > inputBinOreLitresAvailable then \n          outputBinOreLitresRequired = roundUpToPrecision(inputBinOreLitresAvailable / 2) \n          end\n        end\n\n    if outputBinOreLitresRequired > 0 then\n      XFR1.setOutput(inputBinOreID)\n      XFR1.startFor(1)\n      updateBalancerStatusInfo()\n\n      statusMessageTable[\"XFR_Data\"] = {material = inputBinOreName, quantity = outputBinOreLitresRequired}\n      statusMessageTable[\"comment\"]  = \"Transfer started\"\n      return\n      end\n\n    updateBalancerStatusInfo()\n    statusMessageTable[\"XFR_Data\"] = {material = \"--\", quantity = 0}\n    statusMessageTable[\"comment\"]  = \"Inventory Balance OK\"\n    end\n\n    return\n  end\n\n---\nfunction loadTablesForBalancing()\n\n  outBinItemList = OutputBin.getContent()\n  if #outBinItemList > 0 then\n    outputBinContents = {}\n\n    for _,column in ipairs(outBinItemList) do\n      local quantity = math.floor((column.quantity*100)/100)\n      local item = system.getItem(column.id)\n      local item_data = {\n          column.id,\n          item.locDisplayNameWithSize,\n          quantity,\n          item.iconPath\n      }\n      table.insert(outputBinContents, item_data)\n      end\n    end\n\n  inBinItemList = InputBin1.getContent()\n  if #inBinItemList > 0 then\n    inputBinsContents = {}\n    for _,column in ipairs(inBinItemList) do\n      local quantity = math.floor((column.quantity*100)/100)\n      local item = system.getItem(column.id)\n      local item_data = {\n          column.id,\n          item.locDisplayNameWithSize,\n          quantity,\n          item.iconPath\n      }\n      table.insert(inputBinsContents, item_data)\n     end\n    end\n  end\n\n---\nfunction screenPulseTick()\n  animationPulseIndex = animationPulseIndex + 1\n  if animationPulseIndex > #screenPulseTable then animationPulseIndex = 1 end\n  return screenPulseTable[animationPulseIndex]\n  end\n\nfunction containerLoadData(input_percent)\n  mt  = \"_\"\n  lo  = \"-\"\n  med = \"+\"\n  hi  = \"=\"\n    \n  maxBarWidth = 10\n  fill_bar = \"\"\n  barEmpty = math.ceil(maxBarWidth * (1-input_percent))\n  barFilled = maxBarWidth - barEmpty\n    \n  fillCap = 3\n  if fillCap > barFilled then fillCap = barFilled end\n  for i=1,fillCap,1\n    do\n      fill_bar = fill_bar .. lo\n      barFilled = barFilled - 1\n      end\n  \n  fillCap = 3\n  if fillCap > barFilled then fillCap = barFilled end\n  for i=1,fillCap,1\n    do\n      fill_bar = fill_bar .. med\n      barFilled = barFilled - 1\n      end\n\n  fillCap = 3\n  if fillCap > barFilled then fillCap = barFilled end\n  for i=1,fillCap,1\n    do\n      fill_bar = fill_bar .. hi\n      barFilled = barFilled - 1\n      end\n\n  for i=1,barEmpty,1\n    do\n      fill_bar = fill_bar .. mt\n      end\n  \n  return fill_bar\n  \n  end\n\n---\nfunction renderScreen()\n  local ScreenTable = {}\n  local input_percent  = roundDownToPrecision(InputBin1.getItemsVolume()/InputBin1.getMaxVolume())\n  local output_percent = roundDownToPrecision(OutputBin.getItemsVolume()/OutputBin.getMaxVolume())\n    \n    \n  --Parameters (1)\n   ScreenTable[1]=[[\n     local FontName=]] .. FontName ..[[\n     local FontSize=]] .. FontSize ..[[\n     local S_Title=\"]] .. wss_software.title ..[[\"\n     local S_Version=\"]] .. wss_software.version ..[[\"\n     local S_Revision=\"]] .. wss_software.revision ..[[\"\n     local timeStamp=\"]] .. epochTime() ..[[\" \n     local xfer_l_name=\"]] ..OutputBin.getName() .. [[\"\n     local XFRUL_Status=\"]] ..statusMessageTable[\"XFRUL_Status\"] .. [[\"\n     local XFR_material=\"]] ..statusMessageTable[\"XFR_Data\"].material .. [[\"\n     local XFR_quantity=\"]] ..statusMessageTable[\"XFR_Data\"].quantity .. [[\"\n     local comment=\"]] ..statusMessageTable[\"comment\"] .. [[\"\n     local notDeadYet=\"]] ..screenPulseTick() .. [[\"\n     local input_percent=\"]] ..containerLoadData(input_percent) .. [[\"\n     local output_percent=\"]] ..containerLoadData(output_percent) .. [[\"\n   ]]\n\n  -- general layout(2)\n  ScreenTable[2]=[[\n      --Layers\n      local layers={}\n      layers[\"background\"]  = createLayer()\n      layers[\"shading\"]     = createLayer()\n      layers[\"report_text\"] = createLayer()\n      layers[\"footer_text\"] = createLayer()\n      layers[\"header_text\"] = createLayer()\n      \n      --util functions\n      function tidy(valueToRound)\n        precisionDigits = 2\n        precisionValue  = 10^precisionDigits\n        if valueToRound == nil then return 0 end\n        local roundedValue = (math.floor(valueToRound * precisionValue) / precisionValue)\n        return roundedValue\n        end\n        \n      function getRowColsPosition(layout, col, row)\n        if col > layout.cols_wide then col = layout.cols_wide end\n        x_pos = (layout.col_width * col) + layout.margin_left\n        if row > layout.rows_high then row = layout.rows_high end\n        y_pos = (layout.row_height * row) + layout.margin_top\n        return {x_pos = x_pos, y_pos = y_pos}\n      end \n          \n      --Scr Resolution\n      local rx, ry=getResolution()\n      local layout = {}\n      layout.cols_wide = tidy(rx/(FontSize*1.2))\n      layout.col_width = tidy(rx/layout.cols_wide)\n      \n      layout.rows_high = tidy(ry/(FontSize*1.2))\n      layout.row_height = tidy(ry/layout.rows_high)\n      \n      layout.margin_top = tidy((ry * 0.1) / 2)\n      layout.margin_bottom = layout.margin_top\n      layout.margin_left = tidy((rx * 0.1) / 2)\n      layout.margin_right = layout.margin_left\n      \n      --Font Setups\n      local offsetStepPX = 24\n      local fontSizeStep = 2\n      local FontText=loadFont(FontName , FontSize)\n      local FontTextSmaller=loadFont(FontName , FontSize - fontSizeStep)\n      local FontTextBigger=loadFont(FontName , FontSize + fontSizeStep)\n    ]]\n\n    --get data to publish (3)\n    ScreenTable[3]=[[\n      local json=require('dkjson')\n      local input=json.decode(getInput()) or {}\n      local tidyInBinContents=input\t\n    ]]    \n    \n    -- header and footer (4)\n    ScreenTable[4]=[[\n      local vpos = 1\n      publish_to = getRowColsPosition(layout, 1, vpos)\n      textMessage = S_Title .. \" v\" .. S_Version .. \" (\" .. S_Revision .. \")\"\n      addText(layers[\"header_text\"], FontTextSmaller, textMessage, publish_to.x_pos, publish_to.y_pos)\n\n      itemListShort = #tidyInBinContents\n      shortListNotice = \"has \"\n      if itemListShort > 18 then \n        itemListShort = 18 \n        shortListNotice = \"is limited to the first \"\n        end\n    \n      publish_to = getRowColsPosition(layout, 1, vpos+1)\n      textMessage = \"Primary container list \" .. shortListNotice .. #tidyInBinContents .. \" items.\"\n      addText(layers[\"header_text\"], FontTextSmaller, textMessage, publish_to.x_pos, publish_to.y_pos)\n  \n      col = tidy(layout.cols_wide/3)\n      row = layout.rows_high - 3\n      \n      publish_to = getRowColsPosition(layout, col, row)\n      textMessage = \"screen last updated: [\"..timeStamp..\"]\"\n      addText(layers[\"footer_text\"], FontTextSmaller, textMessage, publish_to.x_pos, publish_to.y_pos)\n    ]]\n\n    --- bin contents listing (5)\n    ScreenTable[5]=[[\n      screen_offset = 2\n      index_offset  = 1\n      vpos = tidy((layout.rows_high - #tidyInBinContents - screen_offset - index_offset)/2)\n\n      for ptr=1,itemListShort do\n          local item = tidyInBinContents[ptr][1]\n          local quantity = tidyInBinContents[ptr][2]\n      \n          local row = vpos + ptr\n          local col = 2\n          publish_to = getRowColsPosition(layout, col, row)\n          textMessage = item .. \":\"\n          addText(layers[\"report_text\"], FontText, textMessage, publish_to.x_pos, publish_to.y_pos)    \n      \n          offset = tidy(offsetStepPX * 0.8 * FontSize)\n          textMessage = quantity\n          addText(layers[\"report_text\"], FontText, textMessage, publish_to.x_pos + offset, publish_to.y_pos)    \n          end\n     ]]\n\n  --- XFR-U-L Status Display (6)\n  ScreenTable[6]=[[\n    \n    offset = offsetStepPX * FontSize\n    textMessage = xfer_l_name\n    local row = vpos + 1\n    local col = 2\n    publish_to = getRowColsPosition(layout, col, row)\n    addText(layers[\"report_text\"], FontTextBigger, textMessage, publish_to.x_pos + offset, publish_to.y_pos)    \n\n    row = row + 1\n    publish_to = getRowColsPosition(layout, col, row)\n    textMessage = \"Status : \"..XFRUL_Status\n    addText(layers[\"report_text\"], FontText, textMessage, publish_to.x_pos + offset, publish_to.y_pos)    \n\n    row = row + 1\n    publish_to = getRowColsPosition(layout, col, row)\n    textMessage = \"Working On : \"..XFR_material..\" (\"..XFR_quantity..\")\"\n    addText(layers[\"report_text\"], FontText, textMessage, publish_to.x_pos + offset, publish_to.y_pos) \n\n    row = row + 1\n    publish_to = getRowColsPosition(layout, col, row)\n    textMessage = \"Of Note : \"..comment\n    addText(layers[\"report_text\"], FontText, textMessage, publish_to.x_pos + offset, publish_to.y_pos)    \n\n    row = row + 2\n    publish_to = getRowColsPosition(layout, col, row)\n    textMessage = notDeadYet\n    addText(layers[\"report_text\"], FontText, textMessage, publish_to.x_pos + offset, publish_to.y_pos)    \n\n    row = row + 2\n    publish_to = getRowColsPosition(layout, col, row)\n    textMessage = \"Fill Level (Input Volume) [\" .. input_percent .. \"]\"\n    addText(layers[\"report_text\"], FontText, textMessage, publish_to.x_pos + offset, publish_to.y_pos)    \n    row = row + 1\n    publish_to = getRowColsPosition(layout, col, row)\n    textMessage = \"Fill Level (Output Volume) [\" .. output_percent .. \"]\"\n    addText(layers[\"report_text\"], FontText, textMessage, publish_to.x_pos + offset, publish_to.y_pos)    \n\n  ]]\n  \n  --Animation (7)\n  ScreenTable[7]=[[\n    requestAnimationFrame(5)\n  ]]\n\n  --RENDER\n   function ScreenRender()\n    local screenTemplate=table.concat(ScreenTable)\n\n    Screen.setRenderScript(screenTemplate)\n   end\n   ScreenRender()\n  end\n---\n--- eof ---",
      "filter": {
        "args": [],
        "signature": "onStart()",
        "slotKey": "-5"
      },
      "key": "6"
    },
    {
      "code": "-- library.onStart(2)\n--[[ TimeScript by Jericho (github.com/Jericho1060) ]]\n--[[ snagged from LocuraDU (https://github.com/LocuraDU) ]]\nfunction epochTime()\n   local t = system.getUtcTime()\n    if not utc then t = t + system.getUtcOffset() end\n    local DSEC=24*60*60\n    local YSEC=365*DSEC\n    local LSEC=YSEC+DSEC\n    local FSEC=4*YSEC+DSEC\n    local BASE_DOW=4\n    local BASE_YEAR=1970\n    local _days={-1, 30, 58, 89, 119, 150, 180, 211, 242, 272, 303, 333, 364}\n    local _lpdays={}\n    for i=1,2  do _lpdays[i]=_days[i]   end\n    for i=3,13 do _lpdays[i]=_days[i]+1 end\n    local y,j,m,d,w,h,n,s\n    local mdays=_days\n    s=t\n    y=math.floor(s/FSEC)\n    s=s-y*FSEC\n    y=y*4+BASE_YEAR\n    if s>=YSEC then\n        y=y+1\n        s=s-YSEC\n        if s>=YSEC then\n            y=y+1\n            s=s-YSEC\n            if s>=LSEC then\n                y=y+1\n                s=s-LSEC\n            else\n                mdays=_lpdays\n            end\n        end\n    end\n    j=math.floor(s/DSEC)\n    s=s-j*DSEC\n    local m=1\n    while mdays[m]<j do m=m+1 end\n    m=m-1\n    local d=j-mdays[m]\n    w=(math.floor(t/DSEC)+BASE_DOW)%7\n    if w == 0 then w = 7 end\n    h=math.floor(s/3600)\n    s=s-h*3600\n    n=math.floor(s/60)\n    function round(a,b)if b then return utils.round(a/b)*b end;return a>=0 and math.floor(a+0.5)or math.ceil(a-0.5)end\n    s=round(s-n*60)\n    local weekDaysNames = {\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"}\n    local weekDaysShortNames = {\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"}\n    local monthNames = {\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"}\n    local monthShortNames = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"}\n\n    return string.format(\"%02d : %02d : %02d \",h,n,s) .. weekDaysShortNames[w]..\" / \".. monthShortNames[m]..\" / \".. d ..\" / \".. y\n           \nend",
      "filter": {
        "args": [],
        "signature": "onStart()",
        "slotKey": "-5"
      },
      "key": "7"
    }
  ],
  "methods": [],
  "events": []
}