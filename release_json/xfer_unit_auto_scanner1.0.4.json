{"slots":{"0":{"name":"XFR1","type":{"events":[],"methods":[]}},"1":{"name":"OutputBin","type":{"events":[],"methods":[]}},"2":{"name":"InputBin1","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-3":{"name":"player","type":{"events":[],"methods":[]}},"-2":{"name":"construct","type":{"events":[],"methods":[]}},"-4":{"name":"system","type":{"events":[],"methods":[]}},"-5":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"local tagName = msgTag[\"outBin\"]\nsystem.print(tagName..\":container content change detected\")\n\nlocal retryOutSeconds = OutputBin.updateContent()\nif retryOutSeconds > 0 then \n    unit.setTimer(msgTag[\"outBin\"], retryOutSeconds) \nelse\n    loadTablesForBalancing()\nend\n","filter":{"args":[],"signature":"onContentUpdate()","slotKey":"1"},"key":"0"},{"code":"local tagName = msgTag[\"inBin\"]\nsystem.print(tagName..\":container content change detected\")\n\nlocal retryInSeconds  = InputBin1.updateContent()\n\nif retryInSeconds > 0 then \n    unit.setTimer(msgTag[\"inBin\"], retryInSeconds) \nelse\n    loadTablesForBalancing()\nend\n","filter":{"args":[],"signature":"onContentUpdate()","slotKey":"2"},"key":"1"},{"code":"--- unit.onStart()\nwss_software ={}\nwss_software.id = \"xfer_unit_auto_scanner\"\nwss_software.title = \"Transfer Unit Auto-Scanner / Auto-Balancer\"\nwss_software.version = \"1.0.4\"\nwss_software.revision = \"06 JAN 2023\"\nwss_software.author = \"Michel Vaillancourt <902pe_gaming@wolfstar.ca>\"\n\nsystem.print(\"\\n --------------- \\n\")\nsystem.print(wss_software.title)\nsystem.print(wss_software.version)\n\n---\nprecisionDigits = 2\nprecisionValue  = 10^precisionDigits\ngramsToKG = 1000\nminutes = {}\nminutes[1] = 60\nminutes[2] = minutes[1]*2\nminutes[5] = minutes[1]*5\ntickTimeSeconds = 15\ninputBinPollOffsetSeconds = 2\n\nstatusCodeTable = {}\nstatusCodeTable[1] = {state=\"Stopped\"}\nstatusCodeTable[2] = {state=\"Pending\"}\nstatusCodeTable[3] = {state=\"Jammed\"}\nstatusCodeTable[4] = {state=\"Storage Full\"}\nstatusCodeTable[5] = {state=\"No Output\"}\nstatusCodeTable[6] = {state=\"Running\"}\nstatusCodeTable[7] = {state=\"No Schemas\"}\n\nmsgTag={}\nmsgTag[\"default\"] = wss_software.id\nmsgTag[\"inBin\"]  = \"_inputBinsContents\"\nmsgTag[\"outBin\"] = \"_outputBinContents\"\n\n--- test stuff is plugged in\nsystem.print(\"\\n --------------- \\n\")\nsystem.print(wss_software.id .. \":\".. XFR1.getClass() .. \":\" ..XFR1.getName())\nsystem.print(wss_software.id .. \":\".. InputBin1.getClass() .. \":\" ..InputBin1.getName() .. \":\"..roundDownToPrecision(InputBin1.getItemsVolume()) .. \"L Used\")\nsystem.print(wss_software.id .. \":\".. OutputBin.getClass() .. \":\" ..OutputBin.getName() .. \":\"..roundDownToPrecision(OutputBin.getItemsVolume()) .. \"L Used\")\n\ncontainerVisibleGrid = 7 * 6\noutputBinBigChunk = roundDownToPrecision(OutputBin.getMaxVolume()/containerVisibleGrid)\n\nsystem.print(wss_software.id .. \": Transfer Chunk Cap will be \"..outputBinBigChunk.. \"L\")\n\n---\ninputBinsContents = {}\noutputBinContents = {}\n\nsystem.print(wss_software.id..\":arming timer for first maximum first run delay in [\"..minutes[1]..\"] seconds\")\nunit.setTimer(wss_software.id, minutes[1]) \nunit.setTimer(msgTag[\"outBin\"],tickTimeSeconds)\nunit.setTimer(msgTag[\"inBin\"], minutes[1])\n\n---eof---","filter":{"args":[],"signature":"onStart()","slotKey":"-1"},"key":"2"},{"code":"local tagName = msgTag[\"default\"]\nsystem.print(tagName..\":timer fired\")\nloadTablesForBalancing()\ncheckBalancer()\n\nlocal retryOutSeconds = OutputBin.updateContent()\n\nif retryOutSeconds > 0 then \n    unit.setTimer(msgTag[\"outBin\"], retryOutSeconds) \nend\n\nunit.setTimer(tagName, 15 + retryOutSeconds)","filter":{"args":[{"value":"xfer_unit_auto_scanner"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"3"},{"code":"unit.stopTimer(wss_software.id .. \"_inputBinsContents\")\nunit.stopTimer(wss_software.id .. \"_outputBinContents\")\nunit.stopTimer(wss_software.id)","filter":{"args":[],"signature":"onStop()","slotKey":"-1"},"key":"4"},{"code":"local tagName = msgTag[\"outBin\"]\nsystem.print(tagName..\":timer fired\")\n\nlocal retrySeconds = OutputBin.updateContent()\n\nif retrySeconds == 0 then\n    loadTablesForBalancing()\nelse\n    unit.setTimer(tagName, retrySeconds)\nend","filter":{"args":[{"value":"_outputBinContents"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"5"},{"code":"local tagName = msgTag[\"inBin\"]\nsystem.print(tagName..\":timer fired\")\n\nlocal retrySeconds = InputBin1.updateContent()\n\nif retrySeconds == 0 then\n    loadTablesForBalancing()\nelse\n    unit.setTimer(tagName, retrySeconds + inputBinPollOffsetSeconds)\nend","filter":{"args":[{"value":"_inputBinsContents"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"6"},{"code":"-- library.onStart()\n-- define key functions for use elsewhere\n---\nfunction roundUpToPrecision(valueToRound)\n     if valueToRound == nil then return 0 end\n     local roundedValue = (math.ceil(valueToRound * precisionValue) / precisionValue)\n\treturn roundedValue\n\tend\n\n---\nfunction roundDownToPrecision(valueToRound)\n     if valueToRound == nil then return 0 end\n     local roundedValue = (math.floor(valueToRound * precisionValue) / precisionValue)\n\treturn roundedValue\n\tend\n\n---\nfunction checkBalancer()\n\tsystem.print(wss_software.id .. \":checkBalancer running\")\n\t\n\tunit.stopTimer(wss_software.id)\n\tbalancerStatus = XFR1.getState()\n\tsystem.print(wss_software.id .. \":balancerStatus:\" .. balancerStatus)\n\tif balancerStatus ~= 6 then\n\t\trunBalancer()\n\t  end\n     unit.setTimer(wss_software.id, tickTimeSeconds) \n\tend\n\n---\t\nfunction loadTablesForBalancing()\n    \n  outBinItemList = OutputBin.getContent()\n  if #outBinItemList > 0 then\n    outputBinContents = {}\n\n      for _,column in ipairs(outBinItemList) do\n        local quantity = math.floor((column.quantity*100)/100)\n        local item = system.getItem(column.id)\n        local item_data = {\n            column.id,\n            item.locDisplayNameWithSize,\n            quantity,\n            item.iconPath\n        }\n        table.insert(outputBinContents, item_data)\n        end \n      end\n    \n  inBinItemList = InputBin1.getContent()\n  if #inBinItemList > 0 then \n      inputBinsContents = {}\n      for _,column in ipairs(inBinItemList) do\n        local quantity = math.floor((column.quantity*100)/100)\n        local item = system.getItem(column.id)\n        local item_data = {\n            column.id,\n            item.locDisplayNameWithSize,\n            quantity,\n            item.iconPath\n        }\n        table.insert(inputBinsContents, item_data)\n       end\n      end  \n  \n  system.print(wss_software.id .. \":loadTablesForBalancing: in/out: [\" .. #inputBinsContents .. \"/\" .. #outputBinContents .. \"]\")\n  end\n  \n---\t\nfunction runBalancer()\n  system.print(\"\\n -------[\".. system.getArkTime() ..\"]------- \\n\")\n  system.print(wss_software.id .. \":runBalancer running\")\n  XFR1.stop()\n   \n  if #inputBinsContents == 0 \n        or #outputBinContents == 0 \n        then return end\n    \n  for row, column in ipairs(inputBinsContents) do --- 1\n    inputBinOreLitresAvailable = column[3]\n    outputBinOreLitresRequired = outputBinBigChunk\n    inputBinOreID = column[1]\n    inputBinOreName = column[2]\n    system.print(\" ... Searching for \" .. inputBinOreName .. \" in \" .. OutputBin.getName())\n    oreNotFoundInOutputBin = true\n        \n    for row2, column2 in ipairs(outputBinContents) do\n      if column2[1] == inputBinOreID then \n        system.print(\" ... ... FOUND \" .. inputBinOreName .. \" in \" .. OutputBin.getName())\n        oreNotFoundInOutputBin = false\n        outputBinOreLitresAlreadyPresent = column2[3]\n        outputBinOreLitresRequired = outputBinBigChunk - outputBinOreLitresAlreadyPresent\n\n        system.print(\" ... ... HAVE \" .. outputBinOreLitresAlreadyPresent .. \"L vs NEED \" .. outputBinOreLitresRequired .. \"L\")\n                \n        if outputBinOreLitresRequired > inputBinOreLitresAvailable then outputBinOreLitresRequired = 0 end\n        if outputBinOreLitresAlreadyPresent > inputBinOreLitresAvailable then outputBinOreLitresRequired = 0 end\n      end\n    end\n\n    if oreNotFoundInOutputBin then  \n        system.print(\" ... ... 404 \" .. inputBinOreName .. \"@\" .. OutputBin.getName())\n        outputBinOreLitresRequired = outputBinBigChunk\n        if outputBinOreLitresRequired > inputBinOreLitresAvailable then outputBinOreLitresRequired = roundUpToPrecision(inputBinOreLitresAvailable / 2) end \n        end\n        \n    if outputBinOreLitresRequired > 0 then\n      XFR1.setOutput(inputBinOreID) \n      XFR1.startFor(1)\n      system.print(\":runBalancer xfer started of \" .. column[2] .. \" for total of \" .. outputBinOreLitresRequired .. \"L\")\n      return\n      end\n    end --- 1\n   \n    return \n  end\n---\t\n--- eof ---","filter":{"args":[],"signature":"onStart()","slotKey":"-5"},"key":"7"}],"methods":[],"events":[]}